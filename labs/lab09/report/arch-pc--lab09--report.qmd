---
## Author
author:
  name: Нагорняк Арсений Евгеньевич
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчет по лабораторной работе №9"
subtitle: "Архитектура ЭВМ"
license: "CC BY"
---

# Цель работы
Приобретение навыков написания программ с использованием подпрограмм. Знакомство
с методами отладки при помощи GDB и его основными возможностями
# Задание

ознакомиться с отладчиком GDB
# Теоретическое введение

# 1.2.1. Введение в GNU Linux
Операционная система (ОС) — это комплекс взаимосвязанных программ, предназначенных
для управления ресурсами компьютера и организации взаимодействия с пользователем.
Сегодня наиболее известными операционными системами являются ОС семейства Microsoft
Windows и UNIX-подобные системы.
GNU Linux — семейство переносимых, многозадачных и многопользовательских опера-
ционных систем, на базе ядра Linux, включающих тот или иной набор утилит и программ
проекта GNU, и, возможно, другие компоненты. Как и ядро Linux, системы на его основе, как
правило, создаются и распространяются в соответствии с моделью разработки свободного и
открытого программного обеспечения (Open-Source Software). Linux-системы распространя-
ются в основном бесплатно в виде различных дистрибутивов.
Дистрибутив GNU Linux — общее определение ОС, использующих ядро Linux и набор
библиотек и утилит, выпускаемых в рамках проекта GNU, а также графическую оконную
подсистему X Window System. Дистрибутив готов для конечной установки на пользова-
тельское оборудование. Кроме ядра и, собственно, операционной системы дистрибутивы
обычно содержат широкий набор приложений, таких как редакторы документов и таблиц,
мультимедийные проигрыватели, системы для работы с базами данных и т.д. Существуют
дистрибутивы, разрабатываемые как при коммерческой поддержке (Red Hat / Fedora, SLED /
OpenSUSE, Ubuntu), так и исключительно усилиями добровольцев (Debian, Slackware, Gentoo,
ArchLinux).

# Выполнение лабораторной работы
# шаг 1
Создайем каталог для программам лабораторной работы № 9, переходим в него и создайем файл lab09-1.asm
копируем текст листинга, не забываем файл in_out.asm. Проверяем, что мы увидим результат 2*х+7

([рис. @fig-001]).

![1](image/1.jpg){#fig-001 width=70%}

меняем текст листинга, чтобы добавить ещё одну подпрограмму, которая посчитает 3*х-1 от того значения, которое мы получим
([рис. @fig-002]).

![2](image/2.jpg){#fig-002 width=70%}
начнем работу с отладчиком gdb. Загружаем исполняемый файл в отладчик. Выполняем файл c помощью команды run

([рис. @fig-003]).

![3](image/3.jpg){#fig-003 width=70%}


# шаг 2
 устанавливаем брейкпоинт на метку _start
([рис. @fig-004]).

![4](image/4.jpg){#fig-004 width=70%}

изучаеем дисассимилированный код программы
([рис. @fig-005]).

![5](image/5.jpg){#fig-005 width=70%}
включаем разные режимы псевдографики для изучения текста программы





([рис. @fig-006]).

![6](image/6.jpg){#fig-006 width=70%}



([рис. @fig-007]).

![7](image/7.jpg){#fig-007 width=70%}


добавляем брейкпоинты

([рис. @fig-008]).

![8](image/8.jpg){#fig-008 width=70%}
исполняем 5 инструкций с помощью команды stepi (si) и изучаем изменения значений регистров. смотрим, как регистры меняются с 0х000000000 на 0х000.... - различные числа, что означает, что в регстры eax, ebx ecx edx записываются переменные
вызываем значения первого и второго сообщения, изучаем
и меняем их - H на h и произвольно меняем второе сообщение;

([рис. @fig-009]).

![9](image/9.jpg){#fig-009 width=70%}

меняем значение ebx на 2, проверяем значение и получаем 2

меняем на "2", и получаем 50 - число которое является кодом символа 2 в ASCII.

смотрим, как обрабатываются аргументы. Аргументы распологаются через каждые 4 байта из-за условностей 32-битной Архитектуры - адрес указателя равен 4 байтам.
([рис. @fig-010]).

![10](image/10.jpg){#fig-010 width=70%}


# Выполнение лабораторной работы
запускаем gdb с файлом из листинга и смотрим работу программы. Ответ равен 10, что не является решением нашего примера. По шагам выполняя программу с _start - понимаем, что проблема в том, что не то значение умножается на 4. ставим переменную ebx = 20 (результат умножение) и программа выдает правильное значение.


([рис. @fig-011]).

![11](image/11.jpg){#fig-011 width=70%}
переписываем нашу программу из прошлой лабораторной работы, 6 вариант, для использования подпрограммы calcul вместо только циклов и флагов. По сути, просто выносим саму арифметику в подпрограмму и вызываем её, без глобального переписывания кода
([рис. @fig-012]).

![12](image/12.jpg){#fig-012 width=70%}
# Выводы
я изученил отладку GDB. Приобрел навыки написания
программ с использованием подпрограмм.

# Список литературы{.unnumbered}

::: {#refs}
:::
